import math
import os
import torch
import torch.distributions.constraints as constraints
import pyro
from pyro import poutine
import pyro.distributions as dist
from pyro.infer import SVI, Trace_ELBO
from pyro.optim import Adam
from torch.utils.data import DataLoader
from glimpse_reader import Sampler
from torch.utils.tensorboard import SummaryWriter
from utils import write_summary
from tqdm import tqdm

class FeatureExtraction:
    """ Gaussian Spot Model """
    def __init__(self, data, lr):
        # D - number of pixel along axis
        # data - number of frames, y axis, x axis
        self.data = data
        self.N, self.F, self.D, _ = data._store.shape
        
        # create meshgrid of DxD pixel positions
        x_pixel, y_pixel = torch.meshgrid(torch.arange(self.D), torch.arange(self.D))
        self.pixel_pos = torch.stack((x_pixel, y_pixel), dim=2).to(torch.float32)
        self.pixel_pos = self.pixel_pos.reshape(1,1,self.D,self.D,2)
        
        # drift locs for 2D gaussian spot
        self.target_locs = torch.tensor((self.data.drift[["dx", "dy"]].values.reshape(1,self.F,2) + self.data.target[["x", "y"]].values.reshape(self.N,1,2)), dtype=torch.float32)
        self.target_locs = self.target_locs.reshape(self.N,self.F,1,1,2)
        # scale matrix for gaussian spot
        self.spot_scale = torch.eye(2).reshape(1,1,1,1,2,2)

        pyro.clear_param_store()
        self.epoch_count = 0
        self.optim = pyro.optim.Adam({"lr": lr, "betas": [0.9, 0.999]})
        self.elbo = Trace_ELBO()
        self.svi = SVI(self.feature_model, self.feature_guide, self.optim, loss=self.elbo)
        self.writer = SummaryWriter(log_dir=os.path.join(data.path,"runs", "feature-extraction", "lr{}".format(lr)))
        #writer.add_text("Spot Model", inspect.getsource(spot_model)) # change here
        #writer.add_text("Noise Model", inspect.getsource(noise_model)) # change here
        
    # Ideal 2D gaussian spot
    #@profile
    def gaussian_spot(self, batch_idx, frame_idx, height, width, x0, y0):
        # return gaussian spot with height, width, and drift adjusted position xy
        # select target locs for given indices
        spot_locs = self.target_locs[batch_idx][:,frame_idx] # ind,F,D,D,2
        # adjust for the center of the first frame
        # x0 and y0 can be either scalars or vectors
        spot_locs[...,0] += x0
        spot_locs[...,1] += y0
        rv = dist.MultivariateNormal(spot_locs, scale_tril=self.spot_scale * width.view(width.size()+(1,1)))
        gaussian_spot = torch.exp(rv.log_prob(self.pixel_pos)) * 2 * math.pi * width**2
        # height can be either a scalar or a vector
        return height * gaussian_spot #
 
    
    #@profile
    def locs_feature_model(self, batch_idx, frame_idx):
        N_plate = pyro.plate("sample_axis", self.N, subsample=batch_idx, dim=-4)
        F_plate = pyro.plate("frame_axis", size=self.F, subsample=frame_idx, dim=-3)
        
        # global locs variables
        with N_plate:
            with F_plate:
                # local height and locs
                background = pyro.sample("background", dist.HalfNormal(1000.))
                height = pyro.sample("height", dist.HalfNormal(500.))
                width = pyro.sample("width", dist.Gamma(1, 0.1))
                x0 = pyro.sample("x0", dist.Normal(0.,10.))
                y0 = pyro.sample("y0", dist.Normal(0.,10.))
        locs = self.gaussian_spot(batch_idx, frame_idx, height, width, x0, y0) + background
        return locs


    #@profile
    def locs_feature_guide(self, batch_idx, frame_idx):
        N_plate = pyro.plate("N_plate", self.N, subsample=batch_idx, dim=-4)
        F_plate = pyro.plate("F_plate", size=self.F, subsample=frame_idx, dim=-3)
        
        # global locs variables
        b_loc = pyro.param("b_loc", self.data.background.reshape(self.N,self.F,1,1), constraint=constraints.positive)
        b_beta = pyro.param("b_beta", torch.ones(self.N,self.F,1,1), constraint=constraints.positive)
        
        w_loc = pyro.param("w_loc", torch.ones(self.N,self.F,1,1)*1.5, constraint=constraints.interval(0,5))
        w_beta = pyro.param("w_beta", torch.ones(self.N,self.F,1,1), constraint=constraints.positive)
        
        # local variables
        x0_loc = pyro.param("x_loc", torch.zeros(self.N,self.F,1,1), constraint=constraints.real)
        x0_scale = pyro.param("x_scale", torch.ones(self.N,self.F,1,1), constraint=constraints.positive)
        y0_loc = pyro.param("y_loc", torch.zeros(self.N,self.F,1,1), constraint=constraints.real)
        y0_scale = pyro.param("y_scale", torch.ones(self.N,self.F,1,1), constraint=constraints.positive)
        h_loc = pyro.param("h_loc", self.data.height.reshape(self.N,self.F,1,1), constraint=constraints.positive)
        h_beta = pyro.param("h_beta", torch.ones(self.N,self.F,1,1), constraint=constraints.positive)
        
        with N_plate:
            with F_plate:
                # local height and locs
                pyro.sample("background", dist.Gamma(b_loc[batch_idx][:,frame_idx]*b_beta[batch_idx][:,frame_idx], b_beta[batch_idx][:,frame_idx]))
                pyro.sample("height", dist.Gamma(h_loc[batch_idx][:,frame_idx]*h_beta[batch_idx][:,frame_idx], h_beta[batch_idx][:,frame_idx]))
                pyro.sample("width", dist.Gamma(w_loc[batch_idx][:,frame_idx]*w_beta[batch_idx][:,frame_idx], w_beta[batch_idx][:,frame_idx]))
                pyro.sample("x0", dist.Normal(x0_loc[batch_idx][:,frame_idx], x0_scale[batch_idx][:,frame_idx]))
                pyro.sample("y0", dist.Normal(y0_loc[batch_idx][:,frame_idx], y0_scale[batch_idx][:,frame_idx]))
        
    def epoch(self, n_batch, num_epochs):
        for epoch in tqdm(range(num_epochs)):
            epoch_loss = 0
            for batch_idx in DataLoader(Sampler(self.N), batch_size=n_batch, shuffle=True):
                for frame_idx in DataLoader(Sampler(self.F), batch_size=self.F, shuffle=True):
                    loss = self.svi.step(batch_idx, frame_idx)
                    epoch_loss += loss * len(batch_idx) * len(frame_idx) / (self.N * self.F)
                
            if not (self.epoch_count % 5):
                write_summary(self.epoch_count, epoch_loss, self, self.svi, self.writer, feature=True, mcc=False)
            self.epoch_count += 1

    def save(self):
        torch.save(pyro.param("h_loc").detach().squeeze(), os.path.join(self.data.path, "h.pt"))
        torch.save(pyro.param("h_beta").detach().squeeze(), os.path.join(self.data.path, "h_beta.pt"))
        torch.save(pyro.param("b_loc").detach().squeeze(), os.path.join(self.data.path, "b.pt"))
        torch.save(pyro.param("b_beta").detach().squeeze(), os.path.join(self.data.path, "b_beta.pt"))
        torch.save(pyro.param("w_loc").detach().squeeze(), os.path.join(self.data.path, "w.pt"))
        torch.save(pyro.param("w_beta").detach().squeeze(), os.path.join(self.data.path, "w_beta.pt"))
        torch.save(pyro.param("x_loc").detach().squeeze(), os.path.join(self.data.path, "x0.pt"))
        torch.save(pyro.param("x_scale").detach().squeeze(), os.path.join(self.data.path, "x0_scale.pt"))
        torch.save(pyro.param("y_loc").detach().squeeze(), os.path.join(self.data.path, "y0.pt"))
        torch.save(pyro.param("y_scale").detach().squeeze(), os.path.join(self.data.path, "y0_scale.pt"))
        print("Features were extracted and saved in {}.".format(self.data.path))
